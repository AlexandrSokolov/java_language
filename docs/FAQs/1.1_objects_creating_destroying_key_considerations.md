## Creating and Destroying Objects Key Considerations

### When designing a new class in Java, what key considerations should a programmer think about regarding how instances of that class are created and destroyed?
<details><summary>Show answer</summary>

- Instance Creation Considerations
- Destruction and Lifecycle Considerations
- Memory and Reference Management
- Resource Management Patterns
- General Construction and Destruction Principles

</details>

### What specific groups of topics belong to *Instance Creation Considerations*?
<details><summary>Show answer</summary>

- How you create instances
- How you avoid creating too many

</details>

### What specific topics belong to *How you create instances*?
<details><summary>Show answer</summary>

- Prefer static factory methods
- Consider telescoping constructors vs. builder pattern
- Enforce singleton property when necessary
- Prevent instantiation when appropriate
- Control how and when instances are created

</details>


### What specific topics belong to *How you avoid creating too many*?
<details><summary>Show answer</summary>

- Avoid unnecessary object creation
- Reuse immutable objects
- Reuse shared instances where appropriate
- Cache expensive objects when beneficial

</details>

### What specific topics belong to *Destruction and Lifecycle Considerations*?
<details><summary>Show answer</summary>

- Explicit and timely resource release via close/AutoCloseable
- Avoid finalizers and cleaners; rely on them only as last‑resort safety nets due to non‑deterministic cleanup

Note: _timely_ release == deterministic, immediate, predictable cleanup

</details>

### What specific topics belong to *Memory and Reference Management*?
<details><summary>Show answer</summary>

- Manage object lifetime & reachability:
    - object reachability (strong / weak / soft / phantom)
    - avoiding obsolete references (objects no longer needed)
    - avoiding unintended references (accidental captures, closures, inner classes)
    - avoiding lingering references (references living longer than intended)
- Accidental Retention & Memory Leaks
- Manage long-lived containers to prevent accidental object retention - specific leak sources:
    - caches
    - listeners and observers (Forgotten unregistration = accidental retention = leak)
    - event handlers / callback registration (ad hoc function capture leaks or “closure capture” leaks)
    - thread-local storage

</details>

### Obsolete references vs lingering
<details><summary>Show answer</summary>

Notes:
- _obsolete_ references - “The object is dead, but I forgot to throw away the body.”
    - You no longer need the object.
    - You simply forgot to clear the reference.
    - The reference still exists, but has no logical purpose.
    - This is a usefulness problem, object usefulness ended.
    - The programmer knows it's useless, but forgot to release it.
    - Example in one line: “We already processed the request; why are we still holding its DTO?”
- _lingering_ reference - “The object is still theoretically needed, but it lives much longer than planned.”
    - The reference **is still logically valid**.
    - But it outlives its intended scope, often by accident:
        - stored in a static collection
        - in a cache that never evicts
        - an event listener you forgot to unsubscribe
        - a closure holding context longer than the function call
    - This is a lifetime mismatch problem, object lifetime exceeded expectations.
    - The programmer did not want the reference forever — but the system kept it.
    - Example in one line: “This listener stayed registered 5 hours after the UI closed.”

</details>

### Memory leak vs Accidental retention
<details><summary>Show answer</summary>

- Memory leak ≈ forgetting to release references
- Accidental retention ≈ keeping references you do not actually need anymore

</details>

### Listeners vs Observers vs Event Handlers vs Callback
<details><summary>Show answer</summary>

- They all represent “someone storing references to someone else for later use.”
- This storage is what causes accidental retention.
- The four words differ mainly in **convention**, **intent**, and **pattern**, not in mechanism.


Listeners
- Usually long‑lived.
- Usually registered explicitly with an object.
- Often part of a classical event model (Swing, AWT, Java Beans).
- Usually multiple listeners per source.
- Example: `source.addListener(myListener);`

Observers
- Conceptually similar to listeners, but comes from the Observer pattern.
- More abstract: "someone watching someone else"
- Often used in reactive/event‑stream frameworks (RxJava, Flow).
- Example: `observable.subscribe(myObserver);`

Difference from listener:
- Mostly semantic — Observer means a higher-level, more architectural pattern.
- Listener is a more "concrete API object".

Event Handlers
- More “action-oriented”
- Represent a piece of logic executed when event fires.
- Can be:
    - listeners
    - lambdas
    - anonymous classes
    - method references
- Example: `button.setOnClick(event -> handleClick());`

Callback
- Most general term
- Just "call this function later"
- Not necessarily tied to an event system
- Often passed inline, not registered
- Example: `runAsync(() -> doSomething());`

</details>

### What specific topics belong to *Resource Management Patterns*?
<details><summary>Show answer</summary>

- Prefer try‑with‑resources
- Ensure deterministic release of external resources
- Implement `AutoCloseable` where appropriate

</details>

### What specific topics belong to *General Construction and Destruction Principles*?
<details><summary>Show answer</summary>

- Ensure safe and correct construction (complete initialization, immutability, defensive copying)
    - Consider immutability during construction
    - Consider defensive copying if needed
    - Ensure all required fields are initialized before use
- Design constructor visibility carefully
- Evaluate performance implications realistically
    - Consider performance implications of object creation
    - Avoid object pools unless absolutely necessary

</details>
